<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diamond Diagram (Complete Graph)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 50px;
        }
        .controls {
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>

    <div class="controls">
        <label for="n">Vertices (n): </label>
        <input type="number" id="n" value="6" min="2">

        <label for="r">Radius (r): </label>
        <input type="number" id="r" value="150" min="10">

        <label>
            <input type="checkbox" id="drawPerimeter" checked> Draw Perimeter
        </label>
    </div>

    <canvas id="diamondCanvas" width="600" height="600"></canvas>

    <script>
        const canvas = document.getElementById('diamondCanvas');
        const ctx = canvas.getContext('2d');
        const nInput = document.getElementById('n');
        const rInput = document.getElementById('r');
        const perimeterInput = document.getElementById('drawPerimeter');

        function draw() {
            const n = parseInt(nInput.value);
            const r = parseInt(rInput.value);
            const drawPerimeter = perimeterInput.checked;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate vertices
            const vertices = [];
            for (let i = 0; i < n; i++) {
                // Angle for this vertex
                // We start at -PI/2 to put the first vertex at the top
                const angle = (i * 2 * Math.PI / n) - (Math.PI / 2);
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                vertices.push({x, y});
            }

            // Draw lines connecting every pair of vertices
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    // Check if vertices are adjacent
                    // Indices are i and j (where j > i)
                    // Adjacent if difference is 1, OR if it's the wrap-around pair (0 and n-1)
                    const isAdjacent = (j === i + 1) || (i === 0 && j === n - 1);

                    if (isAdjacent && !drawPerimeter) {
                        continue;
                    }

                    ctx.moveTo(vertices[i].x, vertices[i].y);
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
            }
            ctx.stroke();

            // Draw vertices (optional, but looks nice)
            /*
            ctx.fillStyle = 'black';
            vertices.forEach(v => {
                ctx.beginPath();
                ctx.arc(v.x, v.y, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            */
        }

        // Initial draw
        draw();

        // Event listeners
        nInput.addEventListener('input', draw);
        rInput.addEventListener('input', draw);
        perimeterInput.addEventListener('change', draw);
    </script>

</body>
</html>
